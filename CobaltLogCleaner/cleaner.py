import re
import os
import glob
import time

# Configuration
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
LOG_DIR = os.path.join(BASE_DIR, "input")
OUTPUT_DIR = os.path.join(BASE_DIR, "output")

if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)

HEADER_TEXT = """--[[
    CONTEXT: ROBLOX AUTOMATION / LOG ANALYSIS
    SOURCE: Extracted from Cobalt Executor Logs (.log format)
    
    SUMMARY:
    This script represents a CLEANED REPLAY of gameplay actions.
    Compacted to single-line format for AI readability.
]]
"""

# Remotes to ignore (very spammy/unimportant)
IGNORE_REMOTES = [
    "Logger",
    "EquipItemHandle",
    "UnequipItemHandle",
    "RequestReplicateSound",
    "PlayEnemyHitSound",
]

def extract_remote_name(line):
    """Extract remote name from log line header"""
    match = re.search(r'(Outgoing|Incoming):(\w+)', line)
    if match:
        return match.group(1), match.group(2)
    return None, None

def extract_generated_code(event_content):
    """Extract the generated code block and compact it to single line"""
    lines = event_content.split('\n')
    code_lines = []
    in_code_block = False
    
    for line in lines:
        if '-------------------- Generated Code --------------------' in line:
            in_code_block = True
            continue
        if in_code_block:
            # Skip Cobalt header comments
            stripped = line.strip()
            if stripped.startswith('-- This code was generated by Cobalt'):
                continue
            if stripped.startswith('-- https://github.com/notpoiu/cobalt'):
                continue
            if stripped:
                code_lines.append(stripped)
    
    # Compact to single line
    code = ' '.join(code_lines)
    # Clean up extra spaces
    code = re.sub(r'\s+', ' ', code)
    # Fix formatting
    code = code.replace('( ', '(').replace(' )', ')').replace(' ,', ',')
    
    return code

def process_log_content(content):
    """Process raw log content and extract clean events"""
    events = []
    unique_code = set()
    
    # Split by timestamp lines
    lines = content.split('\n')
    current_event = []
    current_header = None
    
    for line in lines:
        # Check if this is a new event header (starts with timestamp)
        if re.match(r'^\d{4}-\d{2}-\d{2}T', line):
            # Process previous event if exists
            if current_header and current_event:
                event_content = '\n'.join(current_event)
                direction, remote_name = extract_remote_name(current_header)
                
                # Skip Incoming events (response only) and ignored remotes
                if direction == "Incoming":
                    current_header = line
                    current_event = []
                    continue
                    
                if remote_name and remote_name not in IGNORE_REMOTES:
                    # Extract generated code
                    generated_code = extract_generated_code(event_content)
                    
                    if generated_code:
                        # Further simplify - remove "local Event = ..." prefix and make it direct call
                        simplified = generated_code
                        # Remove "local Event = path" and "Event:" to make direct call
                        simplified = re.sub(r'local Event = ([^\s]+)\s+Event:', r'\1:', simplified)
                        # Remove "local Result = " prefix
                        simplified = re.sub(r'local Result = ', '', simplified)
                        # Remove ExpectedResult parts
                        simplified = re.sub(r'\s*local ExpectedResult.*$', '', simplified)
                        
                        # Deduplicate
                        if simplified not in unique_code:
                            unique_code.add(simplified)
                            events.append(simplified)
            
            current_header = line
            current_event = []
        else:
            current_event.append(line)
    
    return events

def process_file(file_path):
    print(f"Processing: {os.path.basename(file_path)}...")
    
    try:
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()
    except Exception as e:
        print(f"  -> Error reading file: {e}")
        return

    events = process_log_content(content)
    
    if not events:
        print("  -> No events found.")
        return

    # Generate output
    base_name = os.path.splitext(os.path.basename(file_path))[0]
    output_path = os.path.join(OUTPUT_DIR, f"{base_name}_clean.lua")
    
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(HEADER_TEXT)
            f.write(f"\n-- Total Unique Events: {len(events)}\n\n")
            
            for evt in events:
                f.write(evt + "\n")
        
        print(f"  -> Created: output/{os.path.basename(output_path)}")
        print(f"     Total: {len(events)} unique events")
    except Exception as e:
        print(f"  -> Error writing output: {e}")

def get_log_files():
    return glob.glob(os.path.join(LOG_DIR, "*.log"))

def main():
    print("=" * 40)
    print("  Cobalt Log Cleaner v3.0")
    print("  Single-line compacted output")
    print("=" * 40)
    print()
    
    if not os.path.exists(LOG_DIR):
        print(f"Input directory not found: {LOG_DIR}")
        print("Please create an 'input' folder and place your .log files there.")
        input("Press Enter to exit...")
        return

    log_files = get_log_files()
    
    if not log_files:
        print(f"No .log files found in: {LOG_DIR}")
        print("Please place your Cobalt .log files in the 'input' folder.")
        input("Press Enter to exit...")
        return
        
    print(f"Found {len(log_files)} log files in 'input' folder")
    print("-" * 30)
    print("1. Process Latest Log")
    print("2. Process All Log Files")
    print("3. Select Log from List")
    print("-" * 30)
    
    choice = input("Enter option (1-3): ").strip()
    
    if choice == '1':
        latest_file = max(log_files, key=os.path.getmtime)
        print(f"\nTarget: {os.path.basename(latest_file)}")
        process_file(latest_file)
        
    elif choice == '2':
        print("\nTarget: All Log Files")
        for f in log_files:
            process_file(f)
            
    elif choice == '3':
        print("\nAvailable Log Files:")
        sorted_files = sorted(log_files, key=os.path.getmtime, reverse=True)
        
        for idx, f in enumerate(sorted_files):
            print(f"{idx+1}. {os.path.basename(f)}")
            
        try:
            selection = int(input("\nEnter number: "))
            if 1 <= selection <= len(sorted_files):
                selected_file = sorted_files[selection-1]
                print(f"\nTarget: {os.path.basename(selected_file)}")
                process_file(selected_file)
            else:
                print("Invalid number selected.")
        except ValueError:
            print("Invalid input. Please enter a number.")
            
    else:
        print("Invalid option selected.")

    print("\nDone.")
    time.sleep(2)

if __name__ == "__main__":
    main()
